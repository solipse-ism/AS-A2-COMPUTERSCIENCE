- ## System Software (target user)
- ### Operating system
	- Kernel is most always store in the ROM and is a part of OS that is always running in the memory
	- **Management**
		- **error detection and recovery**
			- management of interrupt
			- diagnostic and troubleshooter
			- safe mode boot
			- shutdown the system without loss of data
			- restore point/backup
		- **security** (through utility program) ensure data privacy and prevent intrusion, 
			- backup
			- firewall
			- anti-malware
			- access right control and authentication (link to file mangement)
		- **file/storage** (using utility program)
			- Access right mechanism
			- file compression
			- provide file naming convention
			- maintain and keep track of FAT/NTFS
				- Each file allocation units (FAU) is being track for free space and what files is stored on them
				- maintain and keep track of directory structure
					- keep track of action like, cut copy paste, move, open, close, or writing of files
		- **memory**
			- allocate process to memory
			- only allow one address for one process
			- keep track of the block for unused space and regain them
			- manage the movement of data between the memory, processor and secondary storage
			- manage the use of paging/VM and partitioning/segmentation
		- **process**
			- scheduling of process (HL or LL scheduler)
				- keep track of priority and state of process(New,  ready, running, terminated, waiting, suspend)
			- resolution of conflict when two or more processes try to access the same resource, ensure fair access
			- allocates resources to each process and share data between process
			- manage the software interrupt of process
			- allow multitask
			- (breaking process into threads 'probably not a mark')
		- **peripheral**
			- managing the hardware interrupt send from device
			- control peripheral through process
			- keep track for peripheral device and auto install drivers -> plug-and-play
			- manage the power usage
			- management of queue e.g. when printing many files
			- management of buffer to allow different transfer speed and operation speed of 2 devices
		- Hardware computer interface: hide complexity of hardware from developer(when writing software) and user (through CLI, GUI)
		- Platform for application software to run
	- ## **Utility program**
		- Disk defragmentor
		- Disk Formatter
		- Disk content analysis and repair 
		- File compression
		- Virus checker(antimalware)
		- backup software
- ## Program Library: need to be imported into the code (for programmer)
	- **Advantage**
		- Save **time** -> save **money**
			- **Pretested**, **standard function** -> unlikely to have error -> make use of **other programmer's knowledge** -> may be too complex to code
			- improvement to library routine = improvement to program
	- **Disadvantage**
		- compatibility issues: code may not work, missing feature or changes in code during update (hard to fix) -> not meet exact requirement
		- tested doesn't mean best performance, or unknown issue may be missed
	- **Static**: required routine source code will be inserted into the program when compile
	- **Dynamic linked**: precompiled-routine (dll: binary files) when required, it is loaded onto the memory and each processes can use it (they will receive their own copy of DLL function from this memory space to avoid "two process accessing same resource")
		- **Advantage**
			- Program that use this will have small executable fiies
			- change to library doesn't need program to be recompile
				- Receive automatic updates of library function
			- Save memory space and storage space
				- many processes can access same DLL files -> reduce redundancy of library coded in programs
				- it is loaded into memory only when required
		- **Disadvantage**
			- Require DDL to be available and not corrupted
- ## Language translator
	- Both compiler and interpreter convert line by line from source into intermediate code (e.g. Assembly, Bytecode(java), etc.)
	- 
	- Compilers: execute faster (no need interpreter at run time) -> allow cross-compilation (meaning, compile on one computer but exe can be use on other computer) -> no source code distributed (security: code doesn't get change for malicious intent and can't see what the app does) 
		- make exe
		- record error when found and error report done *at the end*
		- if no error on line, convert it to intermediate
		- *at the end*: if no error found then intermediate code get convert to machine code(object)
	- Interpreter: good as a debugger -> can test partially completed program, error seen at real time, changes effect seen at real time (translated statement execute immediately)
		- halt program at error line, when fix it continues
		- doesn't make exe = need source code and interpreter each run-time
	- Assembler Assembly(LLL) => machine code
	- Java: uses a *2-step* **translation process**
		- source code compiled into bytecode by java compiler (javac)
		- any JVM can interpret this, otherwise use JIT(just in time) compiler to compile bytecode to machine code at runtime for better performance
- ## Security and threats
	-  
