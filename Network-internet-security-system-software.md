**- ## System Software (target user)
- ## Operating system
	- Kernel is most always store in the ROM and is a part of OS that is always running in the memory
	- **Management**
		- **error detection and recovery**
			- **management of interrupt**
			- **diagnostic** and **troubleshooter**
			- **safe mode boot**
			- **shutdown the system without loss of data**
			- **restore point/backup**
		- **security** (**see more there in utility program**) ensure data privacy and prevent intrusion, 
			- backup
			- firewall
			- anti-malware
			- **access right control and authentication** (link to file management) (**see more in general security prevention**)
		- **file/storage** (using utility program)
			- Access right mechanism
			- file compression
			- provide file naming convention
			- maintain and keep track of FAT/NTFS
				- Each file allocation units (FAU) is being track for free space and what files is stored on them
				- maintain and keep track of directory structure
					- keep track of action like, cut copy paste, move, open, close, or writing of files
		- **memory**
			- allocate process to memory
			- only allow one address for one process
			- keep track of the block for unused space and regain them
			- manage the movement of data between the memory, processor and secondary storage
			- manage the use of paging/VM and partitioning/segmentation
		- **process**
			- scheduling of process (HL or LL scheduler)
				- keep track of priority and state of process(New,  ready, running, terminated, waiting, suspend)
			- resolution of conflict when two or more processes try to access the same resource, ensure fair access
			- allocates resources to each process and share data between process
			- manage the software interrupt of process
			- allow multitask
			- (breaking process into threads 'probably not a mark')
		- **peripheral**
			- managing the hardware interrupt send from device
			- control peripheral through process
			- keep track for peripheral device and auto install drivers -> plug-and-play
			- manage the power usage
			- management of queue e.g. when printing many files
			- management of buffer to allow different transfer speed and operation speed of 2 devices
		- Hardware computer interface: hide complexity of hardware from developer(when writing software) and user (through CLI, GUI)
		- Platform for application software to run
	- ## **Utility program**
		- **Disk defragmentor**
			- make individual files occupy contiguous block (collates free space)
			- improve access time as reduce head movement of HDD
		- **Disk Formatter**
			- partition disc into logical drive
			- setup the file system (for first use)
			- delete all data from disc
		- **Disk content analysis and repair** 
			- content analysis: find and mark bad sector due to hardware failure
			- repair: try to restore corrupted file or lost data -> if not possible, mark locations as bad sector(not to be use) 
		- **File compression**: to reduce size of file
			- save storage space (may increase computer performance) -> reduce bandwidth needed -> reduce transmission time
		- **Virus checker**(anti-malware)
			- scan for (malware) and check against database of known ones at scheduled time interval
			- quarantine or delete any software that is found to meet
			- need to be updated to keep track with new (malware)
		- **backup**
			- copy of data/files store in another location at scheduled time interval 
			- in an event of data/file loss/corruption, it can be recovered
		- Similar to backup but not utility: **Disk mirroring**
			- simultaneously writing to two disk
			- in an event on hardware failure on one disk, the identical copy is immediately available
		- **Firewall**:
			- monitor incoming and outgoing network traffic and compare to set-criteria
			- Criteria including: whitelist, and blacklist ip address or port number
			- block any traffic that doesn't meet criteria
- ## Program Library: need to be imported into the code (for programmer)
	- **Advantage**
		- Save **time** -> save **money**
			- **Pretested**, **standard function** -> unlikely to have error -> make use of **other programmer's knowledge** -> may be too complex to code
			- improvement to library routine = improvement to program
	- **Disadvantage**
		- compatibility issues: code may not work, missing feature or changes in code during update (hard to fix) -> not meet exact requirement
		- tested doesn't mean best performance, or unknown issue may be missed
	- **Static**: required routine source code will be inserted into the program when compile
	- **Dynamic linked**: precompiled-routine (dll: binary files) when required, it is loaded onto the memory and each processes can use it (they will receive their own copy of DLL function from this memory space to avoid "two process accessing same resource")
		- **Advantage**
			- Program that use this will have small executable fiies
			- change to library doesn't need program to be recompile
				- Receive automatic updates of library function
			- Save memory space and storage space
				- many processes can access same DLL files -> reduce redundancy of library coded in programs
				- it is loaded into memory only when required
		- **Disadvantage**
			- Require DLL to be available and not corrupted
- ## IDE (For programmer)
	- Visual Aid
		- Pretty printing (color coding): identify key term
		- Expanding and collapsing code block
		- auto indentation / formatting
	- Coding aid
		- dynamic syntax check: check for "grammatical" error as code is type, underline those syntax error
		- context-sensitive prompt: help complete statement base on what is type 
		- autocomplete: suggest what to type next
	- debugger (testing aid):
		- Breakpoints: line where the code stop running at to check the variable and expression
		- single stepping (up down, in out of modules): run code line by line to see  the value of the variable
		- Report/watch window: see the how variable and expression change as the program run
			- Variable and expression values (e.g. x = 1, x < a + c = TRUE)
- ## Language translator (for programmer)
	- Both compiler and interpreter convert line by line from source into intermediate code (e.g. Assembly, Bytecode(java), etc.)
	- 
	- Compilers: execute faster (no need interpreter at run time) -> allow cross-compilation (meaning, compile on one computer but exe can be use on other computer) -> no source code distributed (security: code doesn't get change for malicious intent and can't see what the app does) 
		- make exe
		- record error when found and error report done *at the end*
		- if no error on line, convert it to intermediate
		- *at the end*: if no error found then intermediate code get convert to machine code(object)
	- Interpreter: good as a debugger -> can test partially completed program, error seen at real time, changes effect seen at real time (translated statement execute immediately)
		- halt program at error line, when fix it continues
		- doesn't make exe = need source code and interpreter each run-time
	- Assembler Assembly(LLL) => machine code
	- Java: uses a *2-step* **translation process**
		- source code compiled into bytecode by java compiler (javac)
		- any JVM can interpret this, otherwise use JIT(just in time) compiler to compile bytecode to machine code at runtime for better performance
- ## Threats toward security and privacy: some threats use combination of each of these
	- Malware: malicious software
		- Virus: replicate itself, try to corrupt data
		- spyware: record and access data remotely(usually use a key logger) 
	- Hacker: unauthorized, illegal access to a system, may steal data, damage the system or damage the data 
	- Phishing: use of emails, claiming to be an legitimate, ask user to enter a bogus site to get financial or personal data (require user action)
	- Pharming: use of bogus site that redirect to fake website to get financial or personal data, also claim to be legitimate (automatic)
- ## General security prevention
	- Creating private network or smaller network (private ip, use of subnet)
	- proxy server and VPN to redirect attack
	- **Authentication**
		- **Biometric**: can't be guess and is unique for every human
		- **2FA** or **2 Step verification**: **describe it** (use of OTP, answering question previously made by user)
		- **strong password** : **describe it**
		- **Digital signature**: reverse asymmetric encryption
			- hashing algorithm is use on message to produce digest
			- digest encrypt by private key to make digital signature
			- message is sent with digital signature
			- digital signature is decrypted with public key to produce digest
			- message is then gone through hashing algorithm and check if digest is the same
			- if yes then email is authentic
		- **Digital Certificate**: uses digital signature, and certificate is receive from **CA** (**Certification authority**), this is use with website to confirm identity and then performing handshake (**TLS protocol**)
	- **Encryption**: makes data meaningless without decryption key
	- **Access right**
	- **physical measure**: Locker or something
	- token authenticator: e.g. swipe card
- 
**
